# Использование Query Derivation
`Query Derivation` в `Spring Data JPA` — это механизм, позволяющий автоматически генерировать `JPQL`-запросы на основе имен методов в репозиториях. Вместо того чтобы вручную писать запросы, вы просто объявляете методы, именуя их согласно определённым соглашениям, а `Spring Data` анализирует имя метода и создаёт соответствующий запрос.

## Основные принципы
**Именование метода**:\
Название метода должно начинаться с префикса, например, `findBy`, `readBy`, `getBy`, `countBy` или `deleteBy`, за которым следует имя свойства (или их комбинация) сущности, по которому требуется фильтрация.
Например, метод `findByLastName` будет искать все записи, у которых значение поля `lastName` совпадает с переданным параметром.

**Ключевые слова для условий**:\
`Spring Data` поддерживает множество ключевых слов для построения запросов. Вот некоторые из них:

`And, Or` - для объединения условий.\
**Пример**: `findByFirstNameAndLastName(String firstName, String lastName)`

`Between, LessThan, GreaterThan, Is, Not` - для сравнения значений.\
**Пример**: `findByAgeGreaterThan(int age)`

`Like, Contains, StartingWith, EndingWith` - для работы со строками.\
**Пример**: `findByEmailContaining(String emailPart)`

`OrderBy` - для сортировки результатов.\
**Пример**: `findByLastNameOrderByFirstNameDesc(String lastName)`

**Работа с вложенными свойствами**:\
Вы можете строить запросы не только по полям базового класса, но и по вложенным объектам. Для этого используется точечная нотация.
**Пример**: `findByAddressCity(String city)` предполагает, что у сущности есть поле `address`, а у адреса — поле `city`.

## Примеры использования
**Пример 1**: Поиск по одному полю
```java
public interface PersonRepository extends JpaRepository<Person, Long> {
    // Найдёт всех людей с указанной фамилией
    List<Person> findByLastName(String lastName);
}
```
**Пример 2**: Поиск по нескольким полям
```java
public interface PersonRepository extends JpaRepository<Person, Long> {
    // Найдёт всех людей, у которых имя и фамилия совпадают с заданными значениями
    List<Person> findByFirstNameAndLastName(String firstName, String lastName);
}
```
**Пример 3**: Использование сравнительных операторов
```java
public interface PersonRepository extends JpaRepository<Person, Long> {
    // Найдёт всех людей, чей возраст больше заданного значения
    List<Person> findByAgeGreaterThan(int age);
}
```
**Пример 4**: Вложенные свойства
```java
public interface PersonRepository extends JpaRepository<Person, Long> {
    // Предполагается, что у Person есть поле address, а у Address — поле city
    List<Person> findByAddressCity(String city);
}
```
**Пример 5**: Сортировка результатов (в обратном порядке)
```java
public interface PersonRepository extends JpaRepository<Person, Long> {
    // Найдёт всех людей с заданной фамилией и отсортирует их по имени в порядке возрастания
    List<Person> findByLastNameOrderByFirstNameDesc(String lastName);
}
```

## Преимущества и ограничения
**Преимущества**:\
**Сокращение кода**: Нет необходимости писать явные запросы, что снижает количество шаблонного кода.\
**Простота**: Читаемый и интуитивно понятный синтаксис методов.
Быстрая разработка: Ускоряет создание стандартных операций поиска, удаления и подсчёта.

**Ограничения**:\
**Сложные запросы**: Для сложной логики (например, с объединением нескольких сущностей, подзапросами и т.п.) имена методов могут стать слишком длинными и неудобными. В таких случаях рекомендуется использовать аннотацию `@Query`.\
**Поддержка имен**: При изменении имен полей в сущности необходимо обновлять и имена методов в репозиториях, иначе Spring Data не сможет корректно сопоставить запрос.

**Как работает процесс**:\
**Анализ имени метода**:\
При запуске приложения `Spring Data` анализирует интерфейсы репозиториев, ищет методы с известными префиксами (`findBy`, `countBy` и т.д.) и разбивает имя метода на составные части.

**Сопоставление с полями сущности**:\
Полученные части сопоставляются с именами полей в сущности. Если метод, например, называется `findByEmailAndStatus`, `Spring Data` ищет в сущности поля `email` и `status`.

**Генерация запроса**:\
После разбора имени метода, Spring Data генерирует соответствующий `JPQL`-запрос, который затем будет выполнен при вызове метода.

**Обработка результатов**:\
Результаты запроса возвращаются в виде списка, одиночного объекта или другого типа, соответствующего сигнатуре метода.

`Query Derivation` — мощный инструмент, который помогает существенно сократить время разработки стандартных операций работы с данными, позволяя сосредоточиться на бизнес-логике приложения. Если же требуется более гибкая настройка запросов, всегда можно воспользоваться аннотацией `@Query` или спецификациями (`Specification API`).