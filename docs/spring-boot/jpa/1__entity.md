# Работа с сущностями и аннотациями
## 1.1 Создание сущности
Сущность в `Spring JPA` представляет собой `POJO (Plain Old Java Object)`, который отображается на таблицу в базе данных. Для этого используется аннотация `@Entity`. Также можно применить аннотацию `@Table` для задания имени таблицы или дополнительных параметров.

**Person.java**:
```java
@Entity
@Table(name = "person", schema = "schema_name")
public class Person {
   @Id
   @Column(name = "person_id")
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long personId;
   
   @Column(name = "name", nullable = false, length = 50)
   private String name;
   @Column(name = "email", nullable = true, length = 100)
   private String email;
   
   // Геттеры и сеттеры
}
```
## 1.2 Основные аннотации
**@Basic**\
Используется в `JPA` для указания, что свойство или поле является базовым, то есть простым типом данных (например, числовым, строковым, датой и т.п.) и должно быть сопоставлено с колонкой таблицы.\
Если поле не аннотировано ни одной другой специализированной аннотацией (например, @OneToOne, @ManyToOne и т.п.), JPA автоматически рассматривает его как базовое, как если бы на нём стояла аннотация `@Basic`. То есть явное указание `@Basic` не всегда требуется.\
**fetch** (обычно не используется) - можно задать стратегию загрузки значения поля: `FetchType.EAGER` (по умолчанию) – значение загружается вместе с сущностью. `FetchType.LAZY` – значение загружается по требованию, что может быть полезно для оптимизации, если данные не всегда нужны.\
**optional** (обычно не используется) - позволяет указать, допускается ли значение `null` для данного поля. Если `optional = false`, это значит, что значение обязательно должно быть присутствующим.\
(используется только для генерации DDL из сущности)

**@Entity**\
Определяет класс как сущность, которая будет храниться в базе данных.\
**name** (обычно не используется) - задаёт логическое имя сущности, которое используется в JPQL-запросах и при управлении сущностями в контексте персистенции. Если значение не указано, по умолчанию используется не квалифицированное имя класса (без пакета). Это имя никак не влияет на имя таблицы в базе данных (для этого используется аннотация `@Table`).

**@Table**\
Позволяет указать имя таблицы и задать дополнительные параметры (например, имя БД, имя схемы).\
**name** - задает имя таблицы в базе данных, с которой будет ассоциирована данная сущность. Если не указано, по умолчанию используется имя класса сущности (без пакета), преобразованное в нужный регистр в зависимости от настроек JPA-провайдера.\
**schema** - определяет схему базы данных, в которой должна находиться таблица. Схема помогает структурировать объекты базы данных (например, в многофункциональных системах или при наличии нескольких пространств имен). Если не указан, применяется схема по умолчанию для соединения.\
**catalog** (обычно не используется) - указывает каталог (логическую группу) базы данных, в котором находится таблица. Каталог — это концепция, поддерживаемая некоторыми СУБД для организации объектов базы данных. Если не задан, используется значение по умолчанию, зависящее от настроек подключения.\
**uniqueConstraints** (обычно не используется) - позволяет задать уникальные ограничения для таблицы в виде массива объектов UniqueConstraint. Эти ограничения гарантируют уникальность значений в одном или нескольких столбцах, что помогает предотвратить дублирование данных на уровне базы данных.\
(используется только для генерации DDL из сущности)\
**indexes** (обычно не используется) - позволяет определить индексы для таблицы через массив объектов Index. Индексы повышают производительность операций поиска и выборки данных. С их помощью можно указать имя индекса, список столбцов, по которым индексируется таблица, а также дополнительные параметры индекса (например, уникальность).\
(используется только для генерации DDL из сущности)

**@Id**\
Помечает поле, являющееся первичным ключом.

**[@GeneratedValue](1_generatedValueAnnotation)**\
Указывает стратегию генерации значений для первичного ключа (например, `IDENTITY`, `AUTO` и т.д.).
**strategy** - определяет стратегию генерации значений первичных ключей.\
**generator** - позволяет задать имя генератора, который будет использоваться для создания значений идентификаторов. Оно особенно полезно, когда используются стратегии, требующие дополнительной настройки.

**@Column**\
Позволяет задать параметры столбца (например, имя, длину, `nullable`).\
**name** - задает имя столбца в базе данных. Если не указано, по умолчанию используется имя поля сущности. Это позволяет явно задать имя столбца, если оно отличается от имени поля в классе.\
**insertable** - указывает, включать ли это поле в SQL-запросы INSERT. Если установлено в true (по умолчанию), то значение поля будет участвовать при вставке новой записи в базу данных. Если false, то поле не будет включаться в операцию вставки.\
**updatable** - определяет, включать ли это поле в SQL-запросы UPDATE. При значении true (по умолчанию) поле может быть обновлено, а если false, то его значение не будет изменяться при выполнении операций обновления.\
**table** (обычно не используется) - используется для указания имени таблицы, в которой находится столбец, если сущность маппится на несколько таблиц. Обычно не требуется, если сущность отображается на одну таблицу.\
**unique** (обычно не используется) - булево значение, определяющее, должно ли значение этого столбца быть уникальным в таблице. Если установлено в true, то для данного столбца будет создано ограничение уникальности, и база данных не позволит вставить дублирующие значения.\
(используется только для генерации DDL из сущности)\
**nullable** (обычно не используется) - определяет, может ли столбец принимать значение NULL. Значение по умолчанию – true, то есть столбец допускает NULL. Если установить false, то будет создано ограничение, запрещающее вставку null-значений.\
(используется только для генерации DDL из сущности)\
**columnDefinition** (обычно не используется) - позволяет задать конкретное определение столбца в DDL (Data Definition Language) – то есть SQL-фрагмент, описывающий тип столбца и дополнительные параметры. Это полезно, если нужно явно указать тип столбца (например, TEXT, CLOB и т.п.) или добавить специфичные для СУБД настройки. Если не указано, JPA выберет тип на основании типа поля в Java.\
(используется только для генерации DDL из сущности)\
**length** (обычно не используется) - определяет максимальную длину для столбца, в основном применимо к строковым (VARCHAR) полям. Значение по умолчанию – 255 символов. Если требуется изменить максимальную длину, можно указать другое значение.\
(используется только для генерации DDL из сущности)\
**precision** (обычно не используется) - используется для числовых типов (например, BigDecimal) и определяет общее количество цифр (до и после десятичной точки). Если не задано (значение по умолчанию 0), то JPA использует настройки по умолчанию для выбранного типа.\
(используется только для генерации DDL из сущности)\
**scale** (обычно не используется) - тоже применяется для числовых типов и определяет количество цифр после десятичной точки. Например, для значения 123.45 точность равна 5, а scale – 2. Если не указано (значение по умолчанию 0), то используется стандартное поведение СУБД.
(используется только для генерации DDL из сущности)

**@Enumerated**\
Используется для указания того, как следует сохранять значения перечислимых (enum) типов в базу данных. По умолчанию JPA не знает, как именно нужно преобразовать значение enum в базовый тип, понятный СУБД.\
**value** - позволяя выбрать один из двух способов сохранения:\
`EnumType.ORDINAL` - Сохраняется порядковый номер (индекс) значения enum (например, 0, 1, 2 и т.д.).\
Недостаток: Если порядок элементов в enum изменится, это может привести к несоответствию между сохранёнными данными и их смысловым значением.
`EnumType.STRING`:\
Сохраняется имя константы (например, "`ACTIVE`", "`INACTIVE`").
Преимущество: Такой подход более устойчив к изменениям порядка или добавлению новых элементов, поскольку сохраняется именно название.


## 2 Связи между сущностями
`Spring JPA` поддерживает несколько типов связей между сущностями, что позволяет моделировать реальные взаимосвязи данных.

### 1.2.1 Основные типы связей
**[@OneToOne](1_oneToOneAnnotation.md)** – связь один к одному.\
**@OneToMany** – связь один ко многим.\
**@ManyToOne** – связь многие к одному.\
**@ManyToMany** – связь многие ко многим.

### 2.2 Примеры связей
#### One-to-One
В данном примере сущность `Person` имеет связь один к одному с сущностью `PersonProfile`.

**PersonProfile.java**:
```java
@Entity
@Table(name = "person_profile")
public class PersonProfile {
   @Id
   @Column(name = "person_profile_id")
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long personProfileId;
   
   private String address;
   
   // У сущности без внешнего ключа указывать связь не обязательно 
   // mappedBy - имя поля в классе Person, которое ссылается на данную сущность
   @OneToOne(mappedBy = "personProfile")
   private User user;
}
```

**Person.java**:
```java
@Entity
@Table(name = "person")
public class Person {
   @Id
   @Column(name = "person_id")
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long personId;

   private String name;
   
   @OneToOne
   // JoinColumn указывается в сущности с внешним ключом
   // В данном примере таблица person имеет поле person_profile_Id, которое указывает на таблицу person_profile
   // name - имя поля таблицы person (которая содержит внешний ключ)
   // referencedColumnName - имя поля таблицы person_profile (на которую ссылаемся)
   @JoinColumn(name = "person_profile_Id", referencedColumnName = "person_profile_Id")
   private PersonProfile personProfile;
}
```

### One-to-Many и Many-to-One
Пример отношений между департаментом и сотрудниками.

**Department.java**:
```java
@Entity
@Table(name = "department")
public class Department {
   @Id
   @Column(name = "department_id")
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long departmentId;

   private String name;

   // У сущности без внешнего ключа указывать связь не обязательно
   // Связь один-ко-многим указывается в сущности на которую ссылаются
   // mappedBy - имя поля в классе Employee, которое ссылается на данную сущность
   @OneToMany(mappedBy = "department")
   private List<Employee> employees = new ArrayList<>();
}
```
**Employee.java**:
```java
@Entity
@Table(name = "employee")
public class Employee {
   @Id
   @Column(name = "employee_id")
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long employeeId;

   private String fullName;
   
   // Связь многие-к-одному указывается в сущности с внешним ключом
   @ManyToOne
   // JoinColumn указывается в сущности с внешним ключом
   // В данном примере таблица employee имеет поле department_id, которое указывает на таблицу department
   // name - имя поля таблицы employee (которая содержит внешний ключ)
   // referencedColumnName - имя поля таблицы department (на которую ссылаемся)
   @JoinColumn(name = "department_id", referencedColumnName = "person_profile_Id")
   private Department department;
}
```

### Many-to-Many
Пример взаимосвязи между студентами и курсами:

```java
@Entity
@Table(name = "student")
public class Student {
   @Id
   @Column(name = "student_id")
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long studentId;
   
   private String name;
   
   @ManyToMany
   // name - имя промежуточной таблицы для связи student и course
   // joinColumns:
   //   name - имя поля таблицы student (которая содержит внешний ключ)
   //   referencedColumnName - имя поля таблицы student_course (на которую ссылаемся)
   // inverseJoinColumns:
   //   name - имя поля таблицы course (которая содержит внешний ключ)
   //   referencedColumnName - имя поля таблицы student_course (на которую ссылаемся)
   @JoinTable(
     name = "student_course",
     joinColumns = @JoinColumn(name = "student_id", referencedColumnName = "student_id"),
     inverseJoinColumns = @JoinColumn(name = "course_id", referencedColumnName = "course_id")
   )
   private Set<Course> courses = new HashSet<>();
}
```

```java
@Entity
@Table(name = "course")
public class Course {
   @Id
   @Column(name = "course_id")
   @GeneratedValue(strategy = GenerationType.IDENTITY)
   private Long courseId;
   
   private String title;

   // Во второй сущности указывать связь не обязательно
   // mappedBy - имя поля в классе Student, которое ссылается на данную сущность
   @ManyToMany(mappedBy = "courses")
   private Set<Student> students = new HashSet<>();
}
```
**Важно** отметить, что для такой связи обязательно используется промежуточная таблица. В данном примере ей выступает таблица `student_course`\
Поскольку внешний ключ есть в обеих таблицах (`Student` и `Course`), то полное описание связи нужно указать в одной любой сущности, тогда связь во второй таблице указывать не обязательно.